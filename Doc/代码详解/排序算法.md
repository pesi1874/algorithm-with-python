## 快速排序

待排序的集合：[3, 2, 6, 5, 1]，首先将待排序集合的第一个元素设置为基准元素：pivot，pivot=3，创建一个
存放比该基准元素大的列表bigger和一个存放比该基准元素小的列表smaller。遍历剩下的所有元素cols[1:]，与基准元素3作比较。得到
bigger列表[6,5]，smaller列表[2,1]。此时return的返回值为quick_sort([2,1) + [pivot] + quick_sort([6,5])，递归继续执行quick_sort([2,1) 和 quick_sort([6,5])，
quick_sort([2,1) 递归执行完的返回值为[1]+[2],quick_sort([6,5])的返回值为[5]+[6],最后得到
[1]+[2]+[3]+[5]+[6],即[1,2,3,5,6]

### 临界处理

待排序集合本身元素个数小于2

```python
if len(cols) <= 1:
    return cols
```

拆分集合后的较大集合和较小集合元素个数小于2

```python
smaller = quick_sort(smaller) if len(smaller) > 1 else smaller
    bigger = quick_sort(bigger) if len(bigger) > 1 else bigger
```



## 冒泡排序

第一层循环第一次遍历时，未排序的集合为:[3, 2, 6, 5, 1]，第二层循环的作用是产生该集合的每两个元素的索引，即会产生0和1,1和2,2和3,3和4,然后比较每两个元素 的大小，将较大的元素交换至右侧.这样第一层循环第一次遍历之后就会得到列表[2,3,5,1,6]，此时[2,3,5,1]为未排序的列表，[6]为已排序的列表，故进行第二次遍历时，只会遍历未排序的列表，所以第一层循环第二次遍历时，第二层循环会产生0和1,1和2,2和3，最后第一层循环第二次遍历之后就会得到列表[2,3,1,5,6],此时[2,3,1]为为排序的列表 [5,6]为已排序的列表.以此类推最终排完整个列表。

### 临界处理

### 特定变量作用