# 术语

- 二叉树：一般指具有搜索特性的二叉树，即二叉搜索树
- 平衡树、平衡二叉树：一般指具有搜索特性和自平衡特性的自平衡二叉搜索树
- 叶子：一般指没有子节点的节点
- 根：一般指初始节点
- 子树：指根节点延伸后的节点的以下结构

# 树

## 定义：

树是一些节点的集合，一棵树由称作根（root）的节点r以及0个或多个非空的子节点（子树）T1,T2......Tn组成，这些子节点中每一棵的根都来自根r的一条有向的边（edge）所连接

## 种类：

线性结构

- 

非线性结构

- 二叉树

## 参考：

https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/



## 二叉树(Binary Tree)

### 定义：

二叉树的每个节点最多只有两个子节点，即左子树和右子树

### 结构图：

### 满二叉树（Full Binary Tree）

定义：

每个节点都有2个或0个子节点

结构图：

```
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
      
```

```
             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50
```

### 完全二叉树（Complete Binary Tree）

定义：

除了倒数第二层节点的子节点，其他每一层的节点都完整，且倒数第二层节点的子节点都在左侧或缺失

结构图：

```
    		  18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 
```

### 完美二叉树（Perfect Binary Tree）

定义：

倒数第二层的节点都有两个子节点，每一层都是满的

结构图：

```
			  18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
```

## 堆（堆积 Heap）

### 定义：

堆是计算机科学中的一种树状数据结构，基于数组实现，通常为二叉堆，是一种完全二叉树结构。通过堆属性（最大堆或最小堆）排序。

最大堆的父节点总是大于等于子节点，根节点为堆的最大值。最小堆的父节点总是小于等于子节点，根节点为堆的最小值。

堆的主要目的是将最大（或者最小）的节点放在最前面，插入数据时添加到数组尾部

### 结构图：

```
			   9
           /       \  
          8          5  
       /    \       /  \
      6      7     1    4
    /    \  /
   0      3 2
```



### 基本操作：

插入，删除，搜索，获取最大最小节点，交换节点

### 性能：

插入、删除：O(logn)

搜索：O(n)

搜索最大或最小：O(1)

### 分类：

二叉堆、最大最小堆、斐波那契堆

### 应用：

堆排序，优先队列，快速找出集合中的最小最大值

## 哈夫曼树（哈夫曼编码）

### 定义：

基于二叉树，满二叉树

树的每个节点对应字母表中的一个字母，将子节点的加权路径长度定义为其重量乘以其深度。



## 二叉搜索树（Binary Search Tree）

### 定义：

- 二叉搜索树是基于根节点划分的二叉树，每个根节点的左子树上的所有节点（子树）的值均小于根节点（父树）上的值。右子树上所有节点的值均大于根节点上的值。
- 左右子树也分别是二叉搜索树
- 当出现重复节点时，可以将重复节点放置在左子树或右子树，也可以引入节点计数
    - https://www.geeksforgeeks.org/how-to-handle-duplicates-in-binary-search-tree/

### 基本操作：

- 插入
- 删除
- 搜索
- 遍历（七种）：
    - 递归实现前序遍历、中序遍历、后序遍历
    - 堆栈实现前序遍历、中序遍历、后序遍历
    - 队列实现层次遍历

### 结构图：

![二叉搜索树](Pics/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1590719686590.png)

#### 性能：

最好的搜索时间是O(logn)，搜索性能接近二分法。最差的搜索时间：O(n)

### 应用：

中断处理、登记缓存查找



## 自平衡二叉搜索树（Self Balance Binary Search Tree）

### 定义：

基于二叉搜索树

一般二叉搜索树搜索的复杂度取决于目标节点到根节点的距离（树的高度），平衡二叉树可以实现更高效的搜索

设n为二叉树的节点数，当树的高度保持为O(logn)时，称为平衡树

### 基本操作：

- 旋转：
    - 几乎所有平衡树的操作都基于树旋转操作（也有部分基于重构，如替罪羊树），通过旋转操作可以使树趋于平衡。
    - 对一棵二叉搜索树进行搜索、插入、删除等动作，所花的时间与树的高度h成比例，与树的容量n无关。当树维持平衡，也就是让h维持在O(logn)左右，就可以在{O(logn)的复杂度完成各类操作
- 插入
- 删除
- 搜索前驱：
- 搜索后驱：
- 搜索排序（rank）：排名定义为比x小的树的个数加一
- 搜索第k大：即排名为k的数

### 种类：

- AVL树
- 树堆、
- 伸展树
- 红黑树
- 加权平衡树：加权平衡树的每个节点储存这个节点下子树的大小，可以用来实现顺序统计树操作，优势在于占用空间小
- 替罪羊树：基于部分重建，在非平衡的二叉搜索树中，每次操作后检查操作路径，找到最高的满足右子树大小大于平衡因子（alpha）乘以自身大小的节点，重建整个子树。就得到替罪羊树，被重建的子树的原来的根被称为替罪羊节点



## AVL树

### 定义：

基于自平衡二叉搜索树，基于内存实现（memory backed），随机访问速度快，适用于中小数据集。

较早的平衡二叉树之一，是一种全局高度平衡的二叉搜索树，维护平衡的成本较高。通过平衡因子差值决定旋转，左右子树树高差不超过1。只要插入或删除不满足上面的条件就要通过旋转来保持平衡，旋转非常耗费时间的。

如果对插入删除不频繁，查找性能优于红黑树。

### 结构图：

### 性能：

插入、删除性能较差，搜索性能较好（优于红黑树）

最好的搜索时间：O(logn),

### 应用：

- windows对进程地址空间的管理



## B树

### 定义：

基于二叉搜索树，基于硬盘储存实现（storage backed），适用于大规模数据，读取性能较差

### 结构图：

分类：B-树，B+树，B*树

### 性能：

O(logn)

### 应用：

- mysql索引

- 数据库，文件系统



## 红黑树

### 定义：

基于自平衡二叉搜索树，基于硬盘

是一种局部平衡的二叉搜索树

### 结构图：

### 性能：

### 应用：

- Linux进程调度[Completely Fair Scheduler](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler)	[Linux](https://github.com/torvalds/linux/blob/master/include/linux/rbtree.h)
- 虚拟内存管理、跟踪文件描述符和目录
- epoll在内核中的实现，用红黑树管理事件块
- nginx使用红黑树管理timer
- c++的STL，map、set等



## Trie树

### 定义：

字典树，用于统计和排序大量字符串

### 结构图：

### 性能：

### 应用：

- 字符前缀匹配，如搜索引擎搜索提示，IP选路

### 其它：

- 前缀树(prefix tree)：字符串快速检索，字符串排序，最长公共前缀，自动匹配前缀显示后缀。
- 后缀树(suffix tree)：查找字符串s1在s2中，字符串s1在s2中出现的次数，字符串s1,s2最长公共部分，最长回文串
- radix tree(patricia tree, compact prefix tree)
- crit-bit tree（解决耗费内存问题）
- radix tree：用于内存管理、NFS相关查找和网络相关的功能，[Linux](https://github.com/torvalds/linux/blob/master/include/linux/radix-tree.h)



## 跳表（skip list）

### 定义：

对标红黑树

### 结构图：

### 性能：

平均性能O(logn),最差性能O(n)

插入、删除、搜索均为O(logn)

### 应用：

- redis skip list数据结构

# 比较

## 堆 VS 二叉搜索树

- 节点的顺序：二叉搜索树的左子节点小于父节点，右节点大于父节点。最大堆的两个子节点均小于父节点
- 内存占用：二叉搜索树占用的内存空间多余数据节点，因为要对节点对象及左右子节点指针分配内存，堆仅仅使用一个数组，不使用指针
- 复杂度：二叉树必须是平衡的条件下插入、删除数据才能达到最优的O(logn)复杂度，堆可以一直保持O(logn)复杂度。搜索时二叉树较快，堆较慢

## AVL树 VS B树

## B树 VS B+树

- b树的中间节点比b+树多存了value，同样出度的情况下，node更大，相对来说cpu缓存命中率是不如b+树的。

## B+树 VS 红黑树

- 红黑树每个节点值存一对键值对，可以使用类似嵌入式链表的方式实现，数据结构本身不管理内存，比较轻量级。b+树每个节点要存多个键值对，节点结构一般由数据结构自己管，是真正意义上的容器，自己管理内存比较容易做lockfree，一个节点存多个键值对cpu缓存命中率更高，适用于用户态实现的高并发索引

## 红黑树 VS 跳表

- 跳表实现比红黑树简单
- 并发环境下跳表性能更好
- 红黑树有个自平衡的处理过程，插入删除需要重做自平衡，牵涉大量节点。跳表的操作更局部性一点
- 跳表比较消耗内存，但是可以通过调节参数降低消耗，达到跟平衡树结构差不多的性能
- 跳表可以使用双向两边，操作更方便，缓存区域化



