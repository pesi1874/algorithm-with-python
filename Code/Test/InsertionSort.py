# @count_time
# @base_log
def insertion_sort(nums):
    length = len(nums)
    for i in range(1, length):
        print(i, i-1)
        while i > 0 and nums[i-1] > nums[i]:
            nums[i], nums[i-1] = nums[i-1], nums[i]
            i -= 1
            print(nums)
    return nums


if __name__ == '__main__':
    nums = [3, 2, 6, 5, 1]
    nums = []
    # nums = gen_random_list(10000)
    insertion_sort(nums)
    '''
    原理：
    对未排序的列表进行遍历，按顺序依次取出每个待插入元素，将其与已排序的列表中的最末尾元素进行比较，
    若该待插入元素比最末尾元素小，则交换两个元素的位置，同时继续向前与倒数第二个元素进行比较，以此类推直到
    待插入元素不再比已排序列表中的元素小为止。
    
    详解：
    第一层循环第一次遍历时，会将列表划分为已排序列表[3]（只有一个元素可以当做已排序）和未排序列表[2,6,5,1],
    用i > 0 和 i -= 1 控制while循环最多只会循环i次（i为已排序列表的长度），用来遍历已排序列表的所有元素，
    将其与待插入元素进行比较。i=1时，取出待插入元素2进行比较，得到列表[2,3,6,5,1].此时[2,3]为已排序列表，
    [6,5,1]为未排序列表。第一层循环第二次遍历时，取出元素6，此时i=1，由于nums[i-1] > nums[i]这个条件不成立，
    所以相当于元素6是“原地插入”，得到已排序列表[2,3,6],未排序列表[5,1]
    
    特殊处理：
    1.列表长度为0:
        range()函数传入数字小于等于0时不进入循环
    2.列表本身已排好序:
        无
    '''

